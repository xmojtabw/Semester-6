 ## سوال    3.1.1
### ۱. پشتیبانی از ticket و قابلیت‌های مرتبط

**Kerberos V4:**
در نسخه چهارم، تنها پشتیبانی پایه از بلیط (Ticket) وجود دارد و قابلیت‌هایی نظیر تمدید، ارسال مجدد (Forwarding) یا اعمال زمان‌بندی‌های خاص بر بلیط‌ها در نظر گرفته نشده است. این باعث می‌شود کنترل بر اعتبارسنجی کاربر محدود باشد.

**Kerberos V5:**
در نسخه پنجم، ساختار بلیط‌ها پیشرفته‌تر شده و امکان forward، renew و حتی postdate کردن بلیط‌ها فراهم شده است. این ویژگی‌ها انعطاف‌پذیری بیشتری در مدیریت نشست‌ها و احراز هویت‌های طولانی‌مدت یا چندگانه فراهم می‌کند، که برای محیط‌های بزرگ و توزیع‌شده حیاتی است.

---

### ۲. پشتیبانی از احراز هویت بین دامنه‌ای (Cross-Realm)

**Kerberos V4:**
نسخه ۴ فقط از احراز هویت ساده بین دو حوزه (Realm) پشتیبانی می‌کند و امکان انتقال اعتماد به‌صورت transitive وجود ندارد. یعنی اگر Realm A به Realm B اعتماد داشته باشد و B به C، لزوماً A نمی‌تواند به C اعتماد کند.

**Kerberos V5:**
در نسخه پنجم، احراز هویت بین حوزه‌ای به صورت transitive پیاده‌سازی شده است. این یعنی در مثال بالا، A می‌تواند به C اعتماد کند، به شرط وجود یک زنجیره‌ی قابل‌اطمینان از اعتماد بین آن‌ها. این قابلیت برای محیط‌های سازمانی و شبکه‌های بزرگ ضروری است.

---

### ۳. رمزنگاری و انعطاف‌پذیری الگوریتم‌ها

**Kerberos V4:**
رمزنگاری در نسخه چهارم تنها مبتنی بر الگوریتم **DES (Data Encryption Standard)** است. این الگوریتم امروزه ناامن تلقی می‌شود و نمی‌تواند نیازهای امنیتی مدرن را برآورده کند.

**Kerberos V5:**
نسخه پنجم از ساختار قابل‌توسعه‌ای استفاده می‌کند که امکان استفاده از هر الگوریتم رمزنگاری دلخواه (مانند AES یا RC4) را فراهم می‌سازد. در این نسخه، متن رمزشده شامل یک شناسه رمزنگاری (encryption identifier) است که مشخص می‌کند از چه الگوریتمی استفاده شده. این طراحی باعث افزایش سازگاری با استانداردهای جدید و انعطاف‌پذیری امنیتی بیشتر می‌شود.

سوال 3.1.2



در ادامه، به بررسی هدف از افزودن **PKINIT (Public Key Cryptography for Initial Authentication)** در **Kerberos Version 5** می‌پردازیم، و اینکه این ویژگی از دیدگاه عملیاتی و امنیتی چه مشکلاتی را نسبت به نسخه‌ی قبلی برطرف می‌کند. پاسخ با رویکرد آکادمیک و فنی، به زبان فارسی ارائه شده است:

---
## سوال ۳.۱.۲
### استفاده از PKINIT در Kerberos V5

#### بررسی از دیدگاه فنی، امنیتی و عملیاتی

---

###  مشکل در نسخه‌های قبلی (Kerberos V4 و حتی V5 بدون PKINIT)

در Kerberos نسخه‌های اولیه، از **کلید متقارن (symmetric key)** برای احراز هویت اولیه کاربر به KDC (Key Distribution Center) استفاده می‌شود. این روش با چالش‌های زیر مواجه بود:

1. **نیاز به توزیع امن کلیدهای پیش‌اشتراکی:**
   هر کاربر باید یک کلید مشترک با KDC داشته باشد که معمولاً از رمز عبور استخراج می‌شود. این کلید باید به‌صورت امن توزیع شود که در مقیاس‌های بزرگ (مثلاً سازمانی یا بین‌سازمانی) بسیار دشوار و ناکارآمد است.

2. **ضعف در امنیت رمز عبور:**
   اگر رمز عبور ضعیف باشد، حملات brute-force یا dictionary می‌توانند باعث افشای کلید رمزنگاری و در نتیجه جعل بلیط‌ها شوند.

---

###  هدف از معرفی PKINIT در Kerberos V5

**PKINIT** به Kerberos این امکان را می‌دهد که از **رمزنگاری کلید عمومی (Public Key Cryptography)** برای مرحله‌ی اولیه‌ی احراز هویت استفاده کند. در این روش، به‌جای کلید متقارن از **گواهی‌نامه دیجیتال (Digital Certificate)** و جفت کلید عمومی/خصوصی استفاده می‌شود.

---

###  مزایای PKINIT از دیدگاه عملیاتی (Practical):

1. **حذف نیاز به کلیدهای پیش‌اشتراکی برای هر کاربر:**
   دیگر نیازی نیست که هر کاربر یک کلید مشترک با KDC داشته باشد. کافیست KDC به CA (مرجع صدور گواهی) اعتماد داشته باشد.

2. **افزایش مقیاس‌پذیری:**
   در محیط‌های بزرگ (مانند شبکه‌های سازمانی با هزاران کاربر یا ساختارهای cross-realm) مدیریت کلیدهای متقارن مشکل‌ساز است. با PKINIT، تنها صدور و مدیریت گواهی‌ها کافیست.

3. **سازگاری با زیرساخت‌های PKI (Public Key Infrastructure):**
   می‌توان از گواهی‌نامه‌های X.509 استاندارد استفاده کرد، که در بسیاری از سازمان‌ها از قبل موجود هستند.

---

###  مزایای PKINIT از دیدگاه امنیتی (Security):

1. **احراز هویت قوی‌تر و امن‌تر:**
   در PKINIT، حتی اگر رمز عبور کاربر فاش شود، بدون دسترسی به کلید خصوصی او نمی‌توان مرحله‌ی احراز هویت را کامل کرد.

2. **مقاومت در برابر حملات brute-force:**
   به‌دلیل عدم استفاده مستقیم از رمز عبور در رمزنگاری، حملات مبتنی بر حدس زدن رمز عبور بی‌اثر می‌شوند.

3. **پشتیبانی از امضای دیجیتال و صحت پیام:**
   با استفاده از کلید خصوصی، کاربر می‌تواند پیام‌ها را امضا کند و KDC با کلید عمومی صحت آن را بررسی می‌کند. این قابلیت یک لایه امنیتی مهم در برابر جعل پیام یا replay attacks ایجاد می‌کند.

---
## سوال ۳.۲.۱
$K_{KDC}$ = master key
$K_a$ = $h$(Alice password)
$S_A$ = session key
TGT = E("Alice", $S_A$, $K_{KDC}$)
authenticator1 = E(timestamp, $S_A$)
REQUEST= (TGT, authenticator)
TicketToBob = E(“Alice”, $K_{AB}$, $K_B$)
REPLY=E(“Bob”, $K_{AB}$, ticket to Bob, $S_A$)
authenticator2 = E(timestamp, $K_{AB}$)
| sender | message  | receiver  |receiver action|
|:-:|:-:|:-:|:-:|
|Alice| "Alice" wants a TGT | KDC (AS) | creates $S_A$ and TGT
|KDC (AS)| E($S_A$, TGT, $K_A$)|Alice|decrypt it using  $K_A$, get the $S_A$ and creates authenticator1
|Alice|I want to talk to bob,REQUEST|KDC (TGS)| decrypts the TGT, gets the $S_A$ and verifies the authenticator1 then creates TicketToBob and $K_{AB}$ and puts them in REPLY
|KDC (TGS)| REPLY | Alice| gets the TicketToBob and $K_{AB}$
|Alice| TicketToBob, authenticator2 | Bob| decrypts the TicketToBob gets the $K_{AB}$ then verifies the authenticator2
|Bob| E(timestamp+1, $K_{AB}$)|Alice| verifies the timestamp

## سوال ۳.۲.۲
### TGT:
با کلید $K_{KDC}$ رمز می‌شود تا بعدا Alice نتواند خود را جای فرد دیگری جا بزند. اگر با کلید دیگری باشد، مثلا $S_A$ یا $K_A$ در این‌صورت Alice می‌تواند نام خود را تغییر دهد مثلا به Bob و به جای آن اهراز هویت شود. در واقعیت TGT باید ضمانت کند فقط Alice بتواند با آن اهراز هویت شود و اهزار هویت فقط باید توسط KDC انجام شود و نه کس دیگری. رمزنگاری با $K_{KDC}$ می‌تواند این را ممکن بسازد.

### TicketToBob:

طراحی Kerberos به گونه ای است که Stateless باشد و نیز نیاز نباشد مستقیما با سرویس ها ارتباط برقرار کند. همچنین سرویس ها نیازی نداشته باشند تا با KDC ارتباط برقرار کنند. در این حالت سرویس ها با یک بررسی متوجه اهراز هویت Alice می‌شوند. همچنین این Alice است که شروع کننده ارتباط است و هر وقت که میخواهد باید با یک authenticator2 خودش را اثبات کند. اگر TicketToBob به Bob ارسال می‌شد، آنگاه سرویس باید منتظر Alice می‌ماند. این کار به پیاده سازی Stateless و راحت تر کمک می‌کند.


---

### ۳.۳.۱

حمله‌ی Golden Ticket از طریق جعل تیکت سرویس (Ticket Granting Ticket - TGT) در پروتکل Kerberos انجام می‌گیرد. مهاجم با داشتن کلید اصلی (Master key) سرویس Kerberos (کلید رمزنگاری مربوط به حساب krbtgt در Active Directory)، می‌تواند یک TGT جعلی تولید کند که مورد قبول کنترل‌کننده‌ی دامنه (Domain Controller) باشد. مراحل اصلی این حمله به شرح زیر است:

1. **دستیابی به کلید حساب krbtgt**: این کلید معمولاً با دسترسی به حافظه (از طریق ابزارهایی مثل Mimikatz) از کنترل‌کننده‌ی دامنه استخراج می‌شود.
2. **ساخت تیکت جعلی (TGT)**: با استفاده از کلید krbtgt، مهاجم می‌تواند تیکت‌های TGT دلخواهی برای هر کاربری (حتی کاربران با دسترسی بالا مثل domain admin) ایجاد کند.
3. **استفاده از تیکت جعلی برای دسترسی به سرویس‌ها**: مهاجم با این تیکت جعلی می‌تواند به منابع مختلف در شبکه بدون محدودیت زمانی یا سطح دسترسی وارد شود.

اطلاعات مورد نیاز:

* کلید رمزنگاری krbtgt
* نام دامنه و SID دامنه
* نام کاربری هدف (در صورت ساخت تیکت برای کاربر خاص)

---

### ۳.۳.۲

هدف اصلی این حمله، **TGT و سرویس صدور تیکت (Ticket Granting Service - TGS)** در Kerberos است. بخش آسیب‌پذیر، حساب **krbtgt** است که مسئول رمزنگاری و تأیید اعتبار TGT است.

چرا آسیب‌پذیر محسوب می‌شود؟

* کلید krbtgt برای تمام TGTها مشترک است؛ در صورت افشای این کلید، امکان جعل تیکت برای هر کاربری وجود دارد.
* کنترل‌کننده دامنه (DC) اعتبار این تیکت جعلی را بررسی نمی‌کند چون به کلید krbtgt اعتماد کامل دارد.

---

### ۳.۳.۳

**راهکار ۱: چرخش دوره‌ای کلید krbtgt**

* **مزایا**: باعث باطل شدن تمام تیکت‌های جعلی تولیدشده‌ی پیشین می‌شود.
* **معایب**: نیاز به هماهنگی دقیق در محیط AD دارد. اجرای نادرست ممکن است باعث اختلال در اعتبارسنجی شود.

**راهکار ۲: نظارت پیشرفته بر ورودها و فعالیت‌ها با SIEM**

* **مزایا**: امکان شناسایی فعالیت‌های مشکوک با تحلیل الگوهای رفتاری.
* **معایب**: نیاز به منابع، تخصص و پیاده‌سازی سامانه‌های نظارتی پیشرفته دارد.

---

## ۳.۴

### الف)

سیستم Kerberos برای جلوگیری از حملات تکراری (Replay Attacks) به شدت به هم‌زمانی دقیق ساعت بین کلاینت و سرور متکی است. اگر زمان سیستم‌ها هماهنگ نباشد، تیکت صادر شده ممکن است به عنوان نامعتبر شناسایی شود یا امکان جعل تیکت ساده‌تر گردد. این هم‌زمانی معمولاً از طریق پروتکل NTP تأمین می‌شود.

---

### ب)

* **klist**:
لیست تیکت‌های Kerberos موجود در کش کاربر را نمایش می‌دهد، شامل:

  * تیکت های TGT فعال
  * تیکت‌های سرویس
  * زمان انقضا و صدور

* **kinit**:
برای گرفتن یک TGT جدید از KDC به‌کار می‌رود. با اجرای آن و وارد کردن رمز عبور، سیستم یک تیکت جدید در کش قرار می‌دهد.

---

