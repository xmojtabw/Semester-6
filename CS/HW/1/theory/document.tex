\documentclass{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{bytefield}
\usepackage{caption}
\usepackage{forest}
\usepackage{fancyhdr} % Custom headers/footers
\usepackage{colortbl}
\usepackage[left=0.6in, right=0.6in, top=1in, bottom=0.9in]{geometry}
\usepackage{indentfirst}
\usepackage{changepage, titlesec}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float} % Add this in the preamble
\usepackage{adjustbox} % for adjustwidth
\usepackage{multicol} % for side-by-side columns
\setlength{\parindent}{1.5em} % Set indentation size (optional)
\usepackage{amsmath} % Required for align environment
\usepackage{xepersian}

\settextfont{Vazirmatn FD}
\setlatintextfont{Noto Serif} 



\pagestyle{fancy}     % Enable fancy headers
\fancyhf{}            % Clear default header/footer
\renewcommand{\headrulewidth}{0pt} % Disable default header line

\fancyhead[L]{\rule{\textwidth}{1pt}} % Manually add one line
\fancyfoot[C]{\thepage} % Page number in the center of the footer

\newcommand{\colorbitbox}[3]{%
	\rlap{\bitbox{#2}{\color{#1}\rule{\width}{\height}}}%
	\bitbox{#2}{#3}}
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightgreen}{rgb}{0.64,1,0.71}
\definecolor{lightred}{rgb}{1,0.7,0.71}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\ExplSyntaxOn
\NewDocumentCommand{\ReverseWords}{m}
{
	\seq_set_split:Nnn \l_tmpa_seq { ~ } { #1 } % Split words by spaces
	\seq_reverse:N \l_tmpa_seq % Reverse the order of words
	\seq_use:Nn \l_tmpa_seq { ~ } % Join words with spaces and output
}
\ExplSyntaxOff


\begin{document}
	
\author{
	مجتبی ملائی  \\ ۴۰۱۳۱۳۸۳  \\
	\and
	رسول صالحی  \\ 40125933
}
\title{ \huge {\textbf{ تکلیف اول}}}
\date{}
\maketitle
	
	
	
	
	
\section{}
	
	\subsection*{\textbf{محرمانگی (Confidentiality)}}
	\begin{itemize}
		\item اطمینان از اینکه اطلاعات فقط برای افراد مجاز قابل دسترسی هستند و افراد غیرمجاز نمی‌توانند به آن‌ها دسترسی داشته باشند. (برای مثال در سیستم های بانکی حفظ اطلاعات کاربران برای عدم سرقت مالی باید مورد اهمیت واقع شود)
	\end{itemize}
	
	\subsection*{\textbf{یکپارچگی (Integrity)}}
	\begin{itemize}
		\item اطمینان از این که اطلاعات در طول زمان تغییر غیرمجاز نداشته‌اند و همچنان دقیق و کامل هستند. (برای مثال در یک سیستم رای گیری نباید با دستکاری و تغییر آرای ثبت شده باعث نامعتبر بودن نتیجه انتخابات شد)
	\end{itemize}
	
	\subsection*{\textbf{دسترس‌پذیری (Availability)}}
	\begin{itemize}
		\item تضمین اینکه اطلاعات و سیستم‌ها در زمان نیاز برای کاربران مجاز قابل استفاده باشند. (برای مثال در سیستم کنترل هوایی اگر یک پیام دیر و یا اصلا به مقصد نرسد میتواند باعث حوادث هوایی شود)
	\end{itemize}
	
	\hrule

\section{}

\begin{enumerate}
	\item 
	\begin{itemize}
		\item تعداد تکرار حروف به ترتیب بیشترین:
		
		\begin{latin}
			\begin{table}[h!]
				\centering
				\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
					\hline
					E & G & A & P & R & V & M & I & W & K & S & X & N & F & H & O & Q & J & L & D & Z & T & C & B & U & Y \\
					\hline
					23 & 20 & 18 & 17 & 17 & 17 & 16 & 16 & 16 & 16 & 15 & 13 & 12 & 10 & 9 & 9 & 9 & 9 & 9 & 9 & 9 & 8 & 8 & 8 & 7 & 6 \\
					\hline
				\end{tabular}
			\end{table}
		\end{latin}
		
		\item بررسی توزیع آماری: خیر با توزیع زبان انگلیسی مشابه نیست.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=0.8\linewidth,height=6.5cm]{screenshot001}
		\end{figure}

		\item 
		اگر چه این روش باعث شده است تا توزیع آماری متن اصلی با متن رمز شده متفاوت بنظر برسد و حملات آماری را تا حدودی دشوار کرده است، اما همچنان توزیع آماری کتاب(کلید) و متن اصلی تاثیر خود را روی توزیع متن رمز شده خواهند گذاشت. 

	\end{itemize}
	
	\item ‎  ‎
	\begin{itemize}
		\item 
		برای پیدا کردن کلید از تابع زیر استفاده می‌کنیم:
		\begin{latin}
			\begin{lstlisting}[language=Python]
key = ""
for i , j in zip(cipher_text,plain_text):
	if i == ' ':
		continue
	key+= chr((ord(i) - ord(j))%26 + ord('a'))
print(key)
\end{lstlisting}
		\end{latin}
		که خروجی آن برابر است با:
		\textit{expectopatronumharryyelledtryingtoblotthescreamingfromhisearsexp}
		
		با فاصله گذاری مناسب خواهیم داشت:
		

\ReverseWords{expecto patronum harry yelled trying to blot the screaming from his ears exp}
		
		
		\item 
		متن داده شده مربوط به کتاب \textit{\ReverseWords{Harry Potter and the Prisoner of Azkaban}} است. 
	
	\item 
	متن اصلی:
	\begin{latin}
		the one time pad otp is an unbreakable encryption method when used correctly it relies on a truly random key that is as long as the message itself and is never reused since each character in the plaintext is combined with a
		 completely unpredictable key character statistical analysis becomes impossible this guarantees perfect secrecy as long as the key remains unknown and is only used once
	\end{latin}

	
	\end{itemize}
	\item  ‎ ‎  ‎ 
\begin{itemize}
	\item 
	 همچنان توزیع کلمات در کتاب های مختلف یکسان است و ترکیب آنها نیز توزیع یکسانی خواهد داشت. پس در برابر حملات آماری تاثیری نخواهد داشت. اما این کار تا حد کمی میتواند امنیت را در برابر مهاجمی که بخواهد با جست و جوی کتاب ها کلید را پیدا کند، افزایش می‌دهد.
	\item 
	مشکل روش های قبلی غیر تصادفی بودن کلید بود که باعث میشد دارای توزیع های آماری خاصی باشند و در برابر حمله های اماری آسیب پذیر باشند. بنابراین برای جلوگیری از حملات آماری باید کلید کاملا تصادفی باشد. 
	\item
	از OTP استفاده کنیم. از یک کلید یکبار مصرف کاملا تصادفی استفاده کنیم. همچنین بجای جمع از XOR باید استفاده کنیم. 
\end{itemize}	
	
\end{enumerate}

\hrule

\section{}
	\begin{latin}
\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		Step & b0 & b1 & b2 & b3 & b4 & b5 & b6 & b7 & Output (b0) & Feedback (b7 $\oplus$ b3) \\
		\hline
		0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0$\oplus$0=0 \\
		1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1$\oplus$1=0 \\
		2 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0$\oplus$0=0 \\
		3 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1$\oplus$1=0 \\
		4 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0$\oplus$0=0 \\
		5 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1$\oplus$0=1 \\
		6 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0$\oplus$0=0 \\
		7 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1$\oplus$0=1 \\
		8 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0$\oplus$0=0 \\
		9 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0$\oplus$1=1 \\
		10 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 0$\oplus$0=0 \\
		11 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0$\oplus$1=1 \\
		12 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0$\oplus$0=0 \\
		13 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1$\oplus$1=0 \\
		14 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0$\oplus$0=0 \\
		15 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1$\oplus$1=0 \\
		
		\hline
	\end{tabular}
\end{table}
	\end{latin}
	
	\subsection*{محاسبه 16 بیت اول خروجی:}
	\begin{latin} 1000001010101000 \end{latin}
	
	\subsection*{دوره تناوب:}
	\begin{itemize}
		\item بله الگوی خروجی در حال تکرار است که با توجه به خروجی بعد از بیت 12 دوباره تکرار شده پس دوره تناوب آن 12 است.
	\end{itemize}
	
	\subsection*{دلیل ناامن شدن رمز:}
	این اشتباه باعث ناامن شدن رمز می‌شود زیرا:
	\begin{itemize}
		\item \textbf{دوره تناوب کوتاه:}
		دوره تناوب LFSR با فیدبک اشتباه \lr{b7} $\oplus$​\lr{b3} بسیار کوتاه است (12 بیت). این باعث می‌شود الگوی خروجی به سرعت تکرار شود و مهاجم بتواند به راحتی الگو را تشخیص دهد.
		\item \textbf{ضعف در رندوم سازی خروجی:}
		LFSR با فیدبک صحیح \lr{b7}$\oplus$\lr{b1}​ دوره تناوب طولانی‌تری دارد و الگوی خروجی آن تصادفی‌تر به نظر می‌رسد. اما با فیدبک اشتباه، الگوی خروجی قابل پیش‌بینی می‌شود.
		\item \textbf{ملاحظات امنیتی:}
		در طراحی LFSR، باید از فیدبک‌هایی استفاده شود که دوره تناوب را به حداکثر برسانند و الگوی خروجی غیرقابل پیش‌بینی باشد. در این حالت، فیدبک \lr{b7}$\oplus$\lr{b3}​ به دلیل دوره تناوب کوتاه، امنیت سیستم را کاهش می‌دهد.
		
	\end{itemize}
	
	\hrule
\section{}
	
\textbf{پیش فرض های مسئله}

\begin{itemize}
	\item $p = 3$
	\item $q = 11$
	\item $n = p \times q = 3 \times 11 = 33$
	\item $e = 3$ (کلید عمومی)
	\item $d = 7$ (کلید خصوصی)
\end{itemize}

\textbf{1. رمزنگاری پیام‌های $m=2$ و $m=3$:}

فرمول رمزنگاری در RSA به این صورت است:
\begin{equation}
	c = m^e \mod n
\end{equation}

برای $m = 2$:
\begin{equation}
	c = 2^3 \mod 33 = 8
\end{equation}

برای $m = 3$:
\begin{equation}
	c = 3^3 \mod 33 = 27
\end{equation}

پس مقادیر رمزنگاری‌شده به این صورت هستند:

\begin{itemize}
	\item $m = 2 \rightarrow c = 8$
	\item $m = 3 \rightarrow c = 27$
\end{itemize}

همچنین برای امضای آنها داریم:

فرمول امضا در RSA به این صورت است:
\begin{equation}
	s = m^d \mod n
\end{equation}

برای $m = 2$:
\begin{equation}
	s = 2^7 \mod 33 = 128 \mod 33 = 29
\end{equation}

برای $m = 3$:
\begin{equation}
	s = 3^7 \mod 33 = 2187 \mod 33 = 9
\end{equation}

پس امضاها به این صورت هستند:
\begin{itemize}
	\item $m = 2 \rightarrow s = 29$
	\item $m = 3 \rightarrow s = 9$
\end{itemize}

\textbf{بخش دوم سوال:}

\textbf{قسمت اول:}
\begin{equation}
	(2^7) \times (3^7) \mod 20 = 16 = S_f
\end{equation}

\textbf{قسمت دوم:}
\begin{equation}
	m_6 = 6^7 \mod 20 = 16 == S_f
\end{equation}

\textbf{قسمت سوم:}
\begin{equation}
	(x^7) \times (y^7) \mod 20 = (x \times y)^7 \mod 20
\end{equation}

در سمت چپ چون پایه‌ها با هم برابرند، در نتیجه با سمت راست یکی شده و باقی‌مانده آن‌ها بر 20 نیز یکسان خواهد بود.

\textbf{قسمت چهارم:}

حداکثر عددی که کمتر از 33 باشد و از 2 و 3 تشکیل شده باشد عدد 27 است، در نتیجه ماکسیمم ضرر:
\begin{equation}
	3 - 27 = 24
\end{equation}
چون ما فقط با داشتن امضای $s_3$ توانستیم به این برسیم.

\textbf{قسمت پنجم:}

برای جلوگیری از آن می‌توان یک عدد رندوم جنریت کرد و به انتهای پیام اصلی اضافه و کل پیام را امضا کنیم که به این عدد رندوم \textit{nonce} می‌گویند و همچنین مقدار $n$ را بزرگتر کنیم.

	
\hrule
\section{}
\begin{itemize}
	\item \textbf{پایگاه داده شماره‌های ملی:}  
	به علت داده‌هایی با شماره‌های اغلب مشابه \textbf{ECB} مناسب نمی‌باشد و همچنین چون نیاز به حفظ ترتیب دارد \textbf{CTR} نیز مناسب نیست و غیر بهینه است، پس بهترین حالت \textbf{CBC} است که با یک \textbf{IV} باعث محرمانگی دیتا می‌شود.  
	
	\item \textbf{استریم زنده ویدیو:}  
	چون نیاز به عدم تأخیر داریم پس از \textbf{CBC} نمی‌توان استفاده کرد چون وابسته به بلوک قبلی خود می‌باشد و از طرفی \textbf{ECB} باعث می‌شود دیتاهای مشابه در تصویر را لو دهد، پس بهترین گزینه برای انتخاب \textbf{CTR} است که سریع است و امکان رمز کردن موازی را دارد.  
	
	\item \textbf{تصویر بیت‌مپ سیاه و سفید:}  
	به علت داده‌هایی با نواحی بزرگ یکنواخت، \textbf{ECB} مناسب نمی‌باشد زیرا الگوهای تصویر را مخفی نمی‌کند و همچنین چون نیاز به حفظ ترتیب دارد، \textbf{CTR} نیز مناسب نیست و غیر بهینه است، پس بهترین حالت \textbf{CBC} است که با یک \textbf{IV} باعث محرمانگی دیتا می‌شود.  
	
	\item \textbf{برنامه پیام‌رسانی با رمزگذاری سرتاسری:}  
	در این حالت \textbf{CBC} نامناسب است زیرا رمزگشایی هر پیام به قبلی‌های آن وابسته می‌شود و همچنین اگر پیام‌ها شامل متن‌های تکراری باشند، \textbf{ECB} برای آن ناامن می‌شود. پس بهتر است از \textbf{CTR} که مستقلاً رمز و رمزگشایی می‌کند و سریع است به علت موازی بودنش و نیازی هم به \textbf{padding} ندارد، استفاده کنیم.  
	
	\item \textbf{ویرایش فایل رمز شده:}  
	می‌توان از \textbf{ECB} یا \textbf{CTR} برای این کار استفاده کرد، چون به نسبت \textbf{CBC} هر دو سریع‌تر هستند و نیازی به رمزگشایی کل فایل برای ویرایش قسمتی از آن نیست. ولی از بین دو موردی که گفتیم، برای فایل‌های بزرگ باز هم \textbf{CTR} گزینه مناسب‌تر و امن‌تری نسبت به \textbf{ECB} است.  
\end{itemize}
	
	\hrule
\section{}

\begin{enumerate}
	\item
 ‎  ‎ 
	چون از AES در مود \textbf{ECB} استفاده می‌کنیم می‌دانیم که رمز شده هر بلاک جدا از بقیه بلاک ها است. همچنین ساختار HMAC گفته شده به \textbf{Length extension attack} آسیب پذیر است. بنابراین بدون دانستن کلید می‌توانیم یک هش معتبر جدید برای وقتی که متنی به پیام اضافه می‌کنیم بسازیم. حال می‌توانیم رمز شده reciever اول یا مقدار amount یا sender را به انتهای پیام اضافه کنیم(به عنوان یک receiver). سپس هش آن را با استفاده از تنکیک گفته شده افزایش دهیم. بدین صورت می توانیم اطلاعات دریافت کنندگان را تغییر دهیم. همچنین اگر پیام دومی با همان کلید رمز و هش شود، می توانیم گیرندگان پیام اول را به گیرندگان پیام دوم اضافه کنیم، زیرا نشان دادیم که میتوانیم یک بلاک رمز شده به پیام ها اضافه کنیم و یک هش معتبر برای آن بسازیم.
	
	\item 
	 ‎  ‎ 
	حمله طول-افزایی \textbf{(\ReverseWords{Length Extension Attack)} }زمانی ممکن است که از یک تابع هش مانند \lr{SHA-256} با ساختار نامناسب \textbf{\ReverseWords{HMAC = Hash(Key || Message) } }استفاده شود. در این روش، مهاجم می‌تواند بدون دانستن کلید، مقدار جدیدی به پیام اصلی اضافه کند و هش معتبری برای پیام تغییریافته تولید کند. دلیل این موضوع به نحوه‌ی کارکرد توابع هش مانند \lr{SHA-256} برمی‌گردد، که در آن مقدار هش نهایی نه تنها به ورودی بلکه به حالت داخلی \textbf{\ReverseWords{(Internal State) }} تابع هش نیز وابسته است. وقتی مهاجم مقدار هش پیام اولیه را داشته باشد، می‌تواند از این مقدار به عنوان وضعیت میانی تابع هش استفاده کند و یک ادامه‌ی جدید به پیام اضافه کند، سپس هش جدیدی تولید کند که معتبر خواهد بود. این به مهاجم امکان می‌دهد که اطلاعات جدیدی مانند گیرندگان اضافی را بدون داشتن کلید مخفی به پیام اصلی اضافه کند و همچنان یک \textbf{HMAC} معتبر ارائه دهد. 
	
	\item
 ‎  ‎ 
	یک حمله دیگر این است که می‌توانیم در این اپلیکیشن عضو شویم و چند تراکنش انجام دهیم. چون به رمز شده پیام ها دسترسی داریم میتوانیم مقدار رمز شده گیرنده ها و amount و sender دسترسی داشته باشیم. بدین ترتیب وقتی تراکنشی انجام بگیرد که گیرنده یا ارسال کننده اش یکی از گیرنده هایی باشد که ما مقدار رمز شده آن را داریم، میتوانیم آن تراکنش را تشخیص دهیم. همچنین مقدار amount های خاص مثلا \lr{10\textdollar} را میتوانیم بدست آوریم و با خواندن پیام های رمز شده آنها را تشخیص بدهیم. به ترتیب اصل محرمانگی داده ها برای این پروتکل دیگر برقرار نیست زیرا می‌توان تراکنش ها را تشخیص داد.

\item 
\begin{itemize}
	\item 
	از \textbf{AES-GCM} استفاده کنیم.
	\item 
	از HMAC زیر استفاده کنیم:
	\begin{latin}
			HMAC(Key, Message) = Hash( (Key $\oplus$ opad) || Hash( (Key $\oplus$ ipad) || Message ) )
	\end{latin}

\end{itemize}


\end{enumerate}


\hrule

\section{}

\subsection*{\textbf{1. نشان دهید که حمله (MitM) می‌تواند برای شکستن رمزگذاری دوگانه استفاده شود و امنیت AES را به میزان قابل توجهی کاهش دهد.}}

\begin{itemize}
	\item مهاجم ابتدا به یک متن رمز شده و همچنین خود متن رمز نشده آن دست می‌یابد.
	\item سپس مهاجم متن رمز نشده را با تمامی حالات $K_1$ رمز می‌کند.
	\item و همچنین متن رمز شده را با تمامی حالات $K_2$ رمزگشایی می‌کند.
	\item مهاجم به محض یافتن متن مشابه در قسمت‌های ۲ و ۳، کلیدهایی که با آن‌ها به این متن مشترک رسیده را به عنوان کلیدهای $K_1$ و $K_2$ شناسایی می‌کند.
\end{itemize}

امنیت رمزگذاری دوگانه به طور قابل توجهی به همان امنیت یگانه رمزگذاری کاهش می‌یابد زیرا مهاجم می‌تواند به طور مستقل به هر لایه حمله کند. پیچیدگی زمانی حمله $2^n$ است (که در آن $n$ اندازه کلید است)، که بسیار کمتر از $2^{2n}$ مورد انتظار برای رمزگذاری است.



\subsection*{\textbf{2. توضیح دهید که Triple AES چگونه کار می‌کند و چرا در برابر حملات مرد میانی ایمن‌تر است.}}

\textbf{Triple AES (\lr{3-AES}):}
\begin{itemize}
	\item در این روش، داده‌ها سه بار با سه کلید متفاوت رمزگذاری می‌شوند.
	\item این ساختار به عنوان \textbf{Encrypt-Decrypt-Encrypt (EDE)} شناخته می‌شود.
\end{itemize}

\textbf{ایمنی در برابر حملات :MitM}
\begin{itemize}
	\item 
	در برابر حملات MitM ایمن‌تر است، زیرا:
	\begin{itemize}
		\item برای شکستن Triple AES، مهاجم باید هر سه لایه رمزگذاری را به طور همزمان بشکند.
		\item این کار به دلیل افزایش پیچیدگی محاسباتی، عملاً غیرممکن است.
		\item همچنین، Triple AES از طول کلید مؤثر بیشتری استفاده می‌کند (معمولاً ۱۶۸ بیت)، که امنیت را به طور قابل توجهی افزایش می‌دهد.
	\end{itemize}
\end{itemize}



\subsection*{\textbf{3. از نظر امنیت و کارایی، کدام روش ترجیح داده می‌شود؟ \lr{AES-256} را با Triple AES مقایسه کنید.}}

\textbf{\lr{AES-256}:}
\begin{itemize}
	\item از یک کلید ۲۵۶ بیتی استفاده می‌کند.
	\item امنیت آن در برابر حملات کلاسیک بسیار بالا است.
	\item در برابر حملات کوانتومی، امنیت آن به حدود ۱۲۸ بیت کاهش می‌یابد (به دلیل الگوریتم‌های کوانتومی مانند \ReverseWords{Grover's Algorithm} ).
\end{itemize}

\textbf{\ReverseWords{:Triple AES}}
\begin{itemize}
	\item از سه کلید مستقل استفاده می‌کند (معمولاً ۱۶۸ بیت).
	\item امنیت آن در برابر حملات کلاسیک و کوانتومی بسیار بالا است.
	\item در برابر حملات کوانتومی، امنیت آن به حدود ۸۴ بیت کاهش می‌یابد (به دلیل \ReverseWords{Grover's Algorithm} ).
\end{itemize}

\textbf{مقایسه امنیت و کارایی:}
\begin{itemize}
	\item \textbf{امنیت:}
	\begin{itemize}
		\item از لحاظ امنیت، Triple AES امنیت بیشتری نسبت به \lr{AES-256} دارد، زیرا از سه لایه رمزگذاری استفاده می‌کند.
		\item اما در برابر حملات کوانتومی، امنیت Triple AES کمی کمتر از \lr{AES-256} است (۸۴ بیت در مقابل ۱۲۸ بیت).
	\end{itemize}
	\item \textbf{کارایی:}
	\begin{itemize}
		\item از نظر کارایی \lr{AES-256} بهتر است، زیرا فقط یک لایه رمزگذاری دارد.
		\item ولی Triple AES به دلیل سه لایه رمزگذاری، کندتر است و منابع بیشتری مصرف می‌کند.
	\end{itemize}
\end{itemize}

	
\end{document}
