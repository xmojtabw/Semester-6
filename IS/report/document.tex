\documentclass[12pt,a4paper]{report}


\usepackage{listings, color}
\usepackage{xcolor}
% Language & Encoding
\usepackage{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}

% Formatting
\usepackage{setspace}       % For line spacing
\usepackage{geometry}       % For page margins
\geometry{margin=1in}

% Extra Packages
% \usepackage{indentfirst}
\usepackage{changepage, titlesec}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float}
\usepackage{graphicx}       % For including images
\usepackage{hyperref}       % For clickable links & ToC
\usepackage{tocloft}        % ToC customization (optional)
\usepackage{fancyhdr}       % Headers & footers
\usepackage{amsmath,amssymb} % Math support
\usepackage{caption}        % Better captions
\usepackage{lipsum}         % Dummy text (for demo)

\usepackage{xepersian}
\settextfont{B Nazanin}
\setlatintextfont{Times New Roman} 



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}





% Setup for hyperlinks
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	urlcolor=cyan,
	citecolor=red
}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

% Header and Footer style
\pagestyle{fancy}
\fancyhf{}
\rhead{\leftmark}
\lhead{گزارش کارآموزی}
\cfoot{\thepage}


\begin{document}
	
	% Title Page
	\begin{titlepage}
		\centering
		{\scshape\LARGE دانشگاه صنعتی اصفهان \par}
		\vspace{1cm}
		{\scshape\Large مرکز ابررایانش \par  }
		\vspace{1.5cm}
		{\huge\bfseries گزارش کارآموزی \par}
		\vspace{2cm}
		
		\begin{center}
			\includegraphics[width=0.3\linewidth]{iut_logo}
		\end{center}
		
		\begin{center}
			\includegraphics[width=0.7\linewidth]{hpc_logo}
		\end{center}
		
		{\Large نویسنده: مجتبی ملائی \par}
		\vfill
		استادکارآموزی: دکتر فاطمه دلدار \par
		\par سرپرست کارآموزی: آقای محمد صالح محمدی
		\vfill
		{\large \today\par}
	\end{titlepage}
	
	% Abstract
	\begin{abstract}
		من و همکارانم در این دوره کارآموزی ضمن آشنایی با مرکز ابررایانش و افراد متخصص شاغل در این مرکز با استفاده از ابزار های \lr{kubernetes}، \lr{kubervirt} و \lr{ceph} بستری ایجاد کردیم تا بتوانیم ماشین های مجازی ویندوز را با هدف در دسترس بودن کامل\footnote{\lr{Highly available}} و با قابلیت هایی مانند تخصیص منابع به صورت برخط و امکان خودکار سازی\footnote{\lr{automation}} به صورت ایمن در اختیار مصرف‌کنندگان  قرار دهیم.
	\end{abstract}
	
	% Table of Contents
	\tableofcontents
	%\listoffigures
	%\listoftables
	\newpage
	
	% Chapters
\chapter{معرفی}
	\section{پیش‌زمینه من}
	من کارآموزی‌ام را در بعد از ترم ششم آغاز کردم. در این دوران با برخی از گرایش‌ها، زمینه ها و مسیر های مختلف در حوزه کامپیوتر آشنا شدم که از جمله آنها برنامه نویسی سمت سرور\footnote{\lr{back-end}}، امنیت سایبری، شبکه و هوش مصنوعی بود. در این میان به فناوری های سمت  سرور مانند \lr{Linux} علاقه‌مند شدم و این موضوع باعث شد تا تصمیم بگیرم که کارآموزی‌ام را در حوزه های مربوط به سرور ها بگذرانم.
	\section{مرکز ابررایانش شیخ بهائی}
	شبکه ملی محاسبات ابری در سال ۱۳۸۸ با هدف ارائه خدمات کامل و جامع محاسباتی به صنایع و مراکز علمی و تحقیقاتی کشور و با حمایت معاونت علمی و فناوری ریاست جمهوری افتتاح شد.
	
	مرکز ملی محاسبات ابری \footnote{\lr{ National High Performance Computing Center}}(\lr{NHPCC}) به عنوان یکی از چندین مرکز ابررایانه کشور، در آن زمان بخشی از این طرح ملی را در قالب تأسیس مرکز ملی ابررایانه شیخ بهایی اجرا کرد.
	
	تمهیدات در نظر گرفته شده در مرکز ملی محاسبات ابری شیخ بهایی به گونه‌ای است که امکانات سخت‌افزاری و نرم‌افزاری جامع و کامل و همچنین خدمات آموزشی و مشاوره‌ای فنی و تخصصی برای استفاده بهینه (در محل یا از راه دور) در دسترس باشد. 
	\subsection{منظور از یک خوشه \lr{HPC} چیست؟}
	
	محاسبات با کارایی بالا یا \lr{HPC}\footnote{\lr{High Performance Computing}} هنر داشتن مجموعه‌ای از گره‌های پردازشی قدرتمند است که به عنوان یک خوشه (یا گروه‌هایی از آنها) به هم متصل شده‌اند تا مجموعه داده‌های عظیم یا مسائل ریاضی پیچیده چند بعدی را به صورت موازی و در سریع‌ترین زمان ممکن حل کنند. بنابراین \lr{HPC} در مورد محاسبات است.
	
	همچنین ممکن است اصطلاح ابررایانه را بشنوید که مترادف خوشه \lr{HPC} (یا گروه‌هایی از آنها) است. این نام بیشتر به دیدگاه سخت‌افزاری و قدرت آن اشاره دارد که معمولاً به عنوان یک واحد ممیز شناور به نام فلاپ (مانند ترافلاپس، پتافلاپس و ...) محاسبه می‌شود.
	
	به عنوان مثال، می‌توانید دانش‌آموزی را در نظر بگیرید که یک کد بزرگ (نوشته شده در بیش از هزاران خط) دارد و اگر تمایل داشته باشد کد خود را در لپ‌تاپ شخصی خود اجرا کند، چند سال طول می‌کشد تا پردازش تمام شود و نتیجه نهایی را ببیند؟ بنابراین اگر کد خود را به ابررایانه منتقل کنند، در مدت زمان بسیار کوتاهی به نتایج دست می‌یابد.
	\subsection{معماری}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{hpc_arch}
		\caption{اجزای یک خوشه}
		\label{fig:hpcarch}
	\end{figure}
	معمولاً یک خوشه پایه از این اجزای اصلی تشکیل شده است:
	\begin{itemize}
		\item[$\bullet$] 
		یک گره ورود (گره سر)
		\item[$\bullet$] 
		انواع گره‌های محاسباتی
		\item[$\bullet$] 
		یک فضای ذخیره‌سازی مشترک توزیع‌شده
		\item[$\bullet$] 
		سرورهای \lr{GPU} (برای بهره‌مندی از محاسبات گرافیکی عظیم)
		\item[$\bullet$] 
		یک سوئیچ \lr{Infiniband} برای اتصال گره‌ها
		\item[$\bullet$] 
		یک زمان‌بند کار و یک سیستم صف‌بندی
		\item[$\bullet$] 
		یک گره انتقال
		\item[$\bullet$] 
		یک گره پساپردازش
	\end{itemize}
	\subsection{نحوه کار}
		کاربران به گره ورود(گره سر) وارد می‌شوند و فایل‌های ورودی خود را آپلود می‌کنند. سپس کارهای خود را به زمانبند ارسال می‌کنند و در صف انتظار قرار می‌گیرند. سپس زمانبند شروع به ارسال کارهای آنها به تمام گره‌های محاسباتی دیگری که کاربر مجاز به دسترسی به آنها است، می‌کند.
		
	\section{پروژه}
	در برخی از موارد مرکز نیاز دارد تا ماشین‌های مجازی ویندوزی را در اختیار مشتریان خود بگذارد. دلیل استفاده از ویندوز راحتی و سادگی بیشتر برای دانشجویان و مشتریانی است که رشته و تخصص آن‌ها در حوزه کامپیوتر نیست و نیاز دارند تا از قدرت محاسباتی مرکز استفاده کنند. برای این افراد کار با سیستم عامل \lr{Linux} که به طور معمول در خوشه ها استفاده میشود بسیار دشوار است. 
	
	نیاز دیگر این بود که اختصاص ماشین‌ها به مشتریان به صورت خودکار و با کمترین مداخله ممکن از طرف یک نیروی انسانی صورت بگیرد. به همین دلیل استفاده از ابزار هایی مانند \lr{Proxmox} که در این مرکز استفاده می‌شود ممکن نبود.
	
	از طرفی در دسترس بودن و سلامتی این ماشین‌ها مهم ترین رکن آن‌ها است. در واقع این پردازش ها به دلیل زمان‌بر بودن آن‌ها از اهمیت خاصی برخوردار هستند. به عنوان مثال در صورتی که سرور میزبان دچار خطا شود، ماشین مجازی ویندوز نیز از کار می‌افتد و تمام منابع و زمانی که برای پردازش استفاده شده بود به هدر می‌رود. از دید یک مصرف کننده این اتفاق کاملا غیر قابل تحمل است زیرا که ممکن است مصرف کننده زمان لازم برای این اجرای دوباره این پردازش را نداشته باشد.
	
	هدف این پروژه برطرف سازی این مشکلات و نیاز ها بود. در کنار این‌ها قابلیت هایی مانند تخصیص منابع به صورت زنده،‌ اضافه کردن و حذف دیسک ها به صورت زنده و برقرار سازی سطح مناسبی از امنیت از اهداف مهم دیگر این پروژه بودند.
	
	
\chapter{آماده سازی}
	
	\section{آماده سازی کامپیوتر‌ها}
	در اولین ورود به مرکز، نیاز بود تا کامپیوتر های مورد نیاز خودمان را شخصی سازی کنیم. در واقع میبایست سیستم عامل دیگری بر روی کامپیوتر‌ها نصب می‌کردیم تا اطلاعات قبلی آنها پاک شود و همچنین بتوانیم ابزار های مورد نیاز را روی آنها نصب کنیم. کامپیوتر‌های مرکز دارای \lr{BIOS} هستند و همچنین از کارت های گرافیکی قدیمی \lr{Nvidia} استفاده می‌کنند. به همین دلیل هنگامی که میخواستیم سیستم عامل های جدید را بر روی آنها نصب کنیم دچار خطا می‌شدند. بنابراین نهایتا مجبور به استفاده از \lr{iso} های قدیمی شدیم. پس از نصب سیستم عامل \lr{Manjaro} بر روی سیستم‌ها، باید نرم افزار ها و ابزار های لازم مانند مرورگر، ابزار‌های مدیریت بسته، درایورها، کامپایلر‌ها، ابزارهای نصب، ویراشگرهای کد و مدیریت  را نصب می‌کردیم. 
	
	\section{آماده سازی سرور‌ها}
	پس  از آماده سازی کامیپوتر‌ها، یک سرور قدرتمند به نام "رخش" در اختیار ما قرار گرفت. این سرور شامل ۶۴ هسته پردازشی و ۱ ترابایت حافظه \lr{RAM} می‌شد. از ما خواسته شد تا با استفاده از ابزاری به نام \lr{Proxmox} که یک ابزار برای مدیریت مجازی سازی سطح یک است، چند ماشین مجازی لینوکس ایجاد کنیم. این ماشین های مجازی لینوکسی برای ما سرور های واقعی را شبیه سازی می‌کردند. در واقع در این پروژه در فاز توسعه، به جای استفاده از چند سرور فیزیکی، از یک سرور فیزیکی چند سرور مجازی ساختیم و از آنها برای توسعه پروژه استفاده کردیم.  در این سرور های مجازی ما از \lr{Ubuntu Server 2022} به دلیل سازگاری، پایداری بهتر و سادگی استفاده کردیم. 
	\subsection{\lr{Proxmox}}
	
	\lr{Proxmox VE} یک پلتفرم مجازی‌سازی همه‌کاره و منبع باز \footnote{\lr{open-source}} است که دو فناوری مجازی‌سازی مبتنی بر کرنل \footnote{\lr{KVM} }و مجازی‌سازی در سطح سیستم عامل \footnote{\lr{LXC} }را به صورت یکپارچه در کنار هم ارائه می‌دهد. این ابزار قدرتمند با ارائه یک رابط مدیریتی تحت وب یکپارچه و کاربرپسند، امکان مدیریت متمرکز ماشین‌های مجازی و حامل‌ها،\footnote{\lr{Containers}} پیکربندی شبکه‌های پیچیده، تنظیم سیستم‌های ذخیره‌سازی متعدد (مانند \lr{Ceph}, \lr{ZFS}) و پیاده‌سازی قابلیت‌های خوشه‌بندی و جا‌به‌جایی زنده \footnote{\lr{Live Migration}} را فراهم می‌کند تا راه‌حلی مقیاس‌پذیر، باثبات و حرفه‌ای برای دیتاسنترهای کوچک و بزرگ ایجاد کند.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth,height=0.17\textheight]{proxmox}
		\caption{تصویری از صفحه مدیریت سرورها}
		\label{fig:proxmox}
	\end{figure}
	همانطور که در تصویر بالا دیده می‌شود. از برخی ماشین‌ها \lr{back-up} گرفته شده است و برخی از آنها متوقف شده اند. امکان \lr{back-up} گیری و تغییر زنده منابع از مهم‌ترین قابلیت های این ابزار است.
	
	توپولوژی مورد استفاده ما در این پروژه به شکل زیر بود.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{"Untitled diagram _ Mermaid Chart-2025-09-20-072004"}
	\caption{توپولوژی ماشین‌ها}
	\label{fig:untitled-diagram--mermaid-chart-2025-09-20-072004}
\end{figure}
در واقع ماشین‌های مجازی ویندوز بر روی \lr{workernode} ها ایجاد می‌شوند و ماشین \lr{masternode} ماشین های دیگر را کنترل می‌کند. در بخش ارکستراسیون به صورت مفصل نحوه این ارتباط توضیح داده خواهد شد.
	  
\chapter{ارکستراسیون}

ارکستراسیون در دنیای فناوری اطلاعات به فرآیند خودکارسازی استقرار، مدیریت، مقیاس‌گذاری و شبکه‌سازی برای حامل‌ها اطلاق می‌شود. در یک معماری مبتنی بر میکروسرویس‌ها، که یک برنامه به ده‌ها یا صدها جزء مستقل تقسیم می‌شود، ارکستراسیون نقشی حیاتی در هماهنگ‌سازی این اجزا، توزیع بار پردازشی، و تضمین در دسترس بودن و مقاومت در برابر خطا\footnote{\lr{resilience}} برنامه ایفا می‌کند. این مفهوم، مدیریت چرخه عمر حامل‌ها را از سطح یک میزبان منفرد فراتر برده و آن را در مقیاس یک خوشه از سرورها تعریف می‌کند.

\section{معرفی \lr{Kubernetes} }

\lr{Kubernetes} یک پلتفرم ارکستراسیون مبتنی بر حامل\footnote{\lr{Container Orchestration Platform}} متن‌باز و گسترده است که به عنوان یکی از اصلی‌ترین راه‌حل‌ها در این حوزه شناخته می‌شود. این پلتفرم با به کارگیری یک معماری \lr{Master-Worker}\footnote{\lr{Control Plane and Worker Nodes}}، امکان تعریف حالت مطلوب\footnote{\lr{Desired State}} برنامه را از طریق فایل‌های اعلانی\footnote{\lr{Declarative YAML/JSON}} فراهم می‌سازد و سپس به صورت خودکار وظایفی مانند زمان‌بندی حاملها بر روی گره‌های کارگر، نظارت بر سلامت آن‌ها، و بازیابی خودکار را انجام می‌دهد.

مزایای کلیدی \lr{Kubernetes} شامل مقیاس‌پذیری الاستیک\footnote{\lr{Elastic Scalability}} و خودکار (هم به صورت افقی و هم عمودی)، بهینگی در مصرف منابع، قابلیت حمل بالا\footnote{\lr{High Portability}} بین محیط‌های ابری مختلف، و تسهیل فرآیندهای \lr{DevOps}\footnote{\lr{Development and Operations}} و \lr{CI/CD}\footnote{\lr{Continuous Integration and Continuous Delivery/Deployment}} است. در نتیجه، این پلتفرم به عنوان استاندارد اصلی برای اجرا و مدیریت برنامه‌های کاربردی مدرن و مقیاس‌پذیر در محیط‌های هایبرید\footnote{\lr{Hybrid Cloud}} و چندابری\footnote{\lr{Multi-Cloud}} تبدیل شده است.
\section{نحوه کار}

\lr{Kubernetes} با دریافت تعریف حالت مطلوب برنامه از کاربر، به صورت خودکار فرآیندهای مدیریت و هماهنگی حامل‌ها را انجام می‌دهد. کاربران مشخص می‌کنند که برنامه‌شان باید چگونه اجرا شود و \lr{Kubernetes} مسئولیت رساندن سیستم به آن حالت و حفظ آن را بر عهده می‌گیرد.

سیستم به طور مداوم وضعیت فعلی را با حالت مطلوب مقایسه می‌کند. اگر بین این دو تفاوتی وجود داشته باشد، \lr{Kubernetes} به صورت خودکار اقدامات لازم را انجام می‌دهد. به عنوان مثال، اگر یک حامل از کار بیفتد، سیستم به طور خودکار حامل جدیدی را جایگزین آن می‌کند تا برنامه همیشه در حالت مطلوب باقی بماند.

\lr{Kubernetes} حامل‌ها را بین گره‌های مختلف توزیع می‌کند و اطمینان حاصل می‌نماید که از منابع سخت‌افزاری به بهترین شکل ممکن استفاده شود. همچنین شبکه‌های لازم برای ارتباط بین حامل‌ها و تعادل بار بین آنها را به صورت خودکار مدیریت می‌کند تا برنامه به صورت یکپارچه و با کارایی بالا قابل دسترسی باشد.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{kuber_arch}
		\caption{معماری کوبرنتیز}
		\label{fig:kuberarch}
	\end{figure}
	ممکن است نام \lr{K8s} را هم به جای \lr{kubernetes} شنیده باشید که معنای آن حرف \lr{k} در ابتدا و ۸ حرف میان آن و حرف \lr{s} در انتها است. 
\section{کاربرد در پروژه}
	\lr{k8s}
	 به دلیل مقاومت در برابر خطا، بازگشت به حالت مطلوب پس از وقاع خطا،  
	مقیاس پذیری و انعطاف پذیری خوب و ساختار ماژولار\footnote{\lr{Modular}} آن یک گزینه عالی برای مدیریت ماشین های مجازی ویندوزی و دیگر چیز های مورد نیاز آنها است. در اصل یکی از نیاز‌های اصلی پروژه که در دسترس بودن دائمی و مقاومت در برابر خطا است که به کمک \lr{k8s} رفع می‌شود. 
	
	نکته حائز اهمیت این است که \lr{k8s} به تنهایی تمام کار‌ها را انجام نمی‌دهد. در واقع این ابزار فقط بستر را برای حامل‌ها فراهم می‌سازد. به دلیل امکان تعریف منابع دلخواه و در نتیجه آن، قابلیت توسعه پذیری و بالای این ابزار، افزونه\footnote{\lr{plugins}}‌های بسیار زیادی برای انجام کار های مختلف وجود دارد. برخی از این افزونه ها مربوط به سیستم داخلی خود \lr{k8s} است مانند افزونه های شبکه که در ادامه معرفی می‌شوند و یا افزونه هایی که یک سرویس کامل را اجرا میکنند مانند \lr{kubevirt} که در ادامه پروژه به آن نیاز داشتیم.
\section{جزئیات نصب \lr{k8s}}
	در هنگام نصب \lr{k8s} نکات زیادی باید رعایت شوند. مثلا بسته به نوع اینکه گره اصلی\footnote{\lr{master}} است یا کارگر\footnote{\lr{worker}} دستورات متفاوتی وجود دارد. اما همه گره‌ها پیش‌نیاز های مورد نیاز یکسانی را دارند. مثلا  حداقل منابع \lr{RAM} و \lr{CPU} و \lr{Disk} و بعد از آن یک شبکه که در آن گره‌ها بتوانند بهم متصل شوند، همچنین خاموش بودن \lr{Swap} و بارگذاری یکسری کرنل ماژول‌ها\footnote{\lr{Kernel modules}} و باینری‌های مورد نیاز از جمله این پیش‌نیاز‌ها هستند. بعد از آنکه این پیش‌نیازها فراهم شد، با استفاده از دستورات مربوط به پیوستن گره‌ها گره های کارگر را به گره اصلی متصل می‌کنیم.
\begin{table}[H]
	\begin{footnotesize}
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline
			\lr{primary disk} & \lr{RAM} & \lr{CPU} & \lr{role} & \lr{NIC(ens19)} & \lr{NIC(ens18)} & \lr{hostname} & \lr{username} \\
			\hline
			\lr{64 GB} & \lr{10 GB} & \lr{4} & \lr{control plane} & \lr{-} & \lr{192.168.170.190} & \lr{masternode} & \lr{master} \\
			\hline
			\lr{64 GB} & \lr{32 GB} & \lr{8} & \lr{worker} & \lr{used for br1} & \lr{192.168.170.191} & \lr{worker1node} & \lr{worker1node} \\
			\hline
			\lr{64 GB} & \lr{32 GB} & \lr{8} & \lr{worker} & \lr{used for br1} & \lr{192.168.170.192} & \lr{worker2node} & \lr{worker2node} \\
			\hline
		\end{tabular}
	\end{footnotesize}
	\caption{مشخصات سرورهای مجازی در k8s}
	\label{tab:cluster_nodes}
\end{table}	
	جدول بالا ویژگی‌ها و مشخصات هر گره را نشان می‌دهد. در فصل بعدی قسمت شبکه هر نود کاملا توضیح داده خواهد شد. 

\chapter{پیاده‌سازی شبکه}
	بحث شبکه یکی از چالشی ترین قسمت های این پروژه بود. زیرا ما سه شبکه متفاوت را مدیریت می‌کردیم. شبکه اول، شبکه داخلی و اصلی بین گره‌ها است. این شبکه بر روی رابط\footnote{\lr{interface}} \lr{ens18} هر گره و با آدرس آیپی\footnote{\lr{IP Address}}\lr{ 192.168.170.19x/24 }به صورت آیپی ثابت مشخص شده است. این تنظیمات بر روی \lr{netplan} هر گره نوشته شده است و توسط گره‌ها اجرا می‌شود. 
	
	شبکه دوم شبکه داخلی \lr{k8s} است که بر پایه شبکه اول پیاده سازی شده است. مدیریت این شبکه با \lr{calico} است که یک \lr{CNI} برای مدیریت شبکه داخلی \lr{k8s} است. این شبکه برای ارتباط بین \lr{pod}\footnote{یک منبع تعریف شده در \lr{k8s} که یک یا تعدادی حامل را در خود نگه می‌دارد. کوچک ترین واحد محاسباتی در \lr{k8s}} ها استفاده می‌شود. رنج آیپی آن نیز \lr{10.0.0.0/8} است. این شبکه به دلیل داخلی بودن قابل دسترسی از بیرون \lr{k8s} نیست. 
	
	شبکه سوم نیز برای ماشین های ویندوز در نظر گرفته شده است. این شبکه به صورت عمومی باشد تا کاربران بتوانند به آن وصل شوند. چون دو شبکه دیگر کاملا داخلی هستند. این شبکه بر روی رابط \lr{ens19} است و رنج آیپی آن نیز \lr{192.168.172.0/24} است که توسط \lr{DHCP} سرور آیپی ها به ماشین های ونیدوز اختصاص داده می‌شوند. 
	\section{\lr{Calico}}
	\lr{calico} یک افزونه شبکه‌ای برای \lr{k8s} است که به عنوان یک \lr{CNI}\footnote{\lr{Container Network Interface}: رابط استاندارد برای اتصال حامل‌ها به شبکه} عمل می‌کند. وظیفه اصلی آن فراهم کردن اتصال شبکه‌ای میان پادهاست، به طوری که همه پادها بتوانند در سراسر خوشه یکدیگر را ببینند و داده تبادل کنند. \lr{calico} با استفاده از \lr{BGP}\footnote{\lr{Border Gateway Protocol}: پروتکل مسیریابی بین شبکه‌ها} و مکانیزم‌های ساده اما کارآمد مسیریابی، به جای تونل‌زنی پیچیده، مسیرهای ارتباطی را مدیریت می‌کند. این موضوع باعث می‌شود که هم کارایی بالاتری داشته باشد و هم عیب‌یابی شبکه راحت‌تر انجام شود. علاوه بر این، \lr{calico} قابلیت پیاده‌سازی سیاست‌های امنیتی شبکه (\lr{Network Policy}\footnote{\lr{Network Policy}: مجموعه‌ای از قوانین امنیتی برای کنترل ترافیک بین پادها}) را هم دارد که به مدیر خوشه اجازه می‌دهد ترافیک میان سرویس‌ها را محدود یا مجاز کند.
	
	در این پروژه هم از \lr{Calico} به عنوان \lr{CNI} اصلی خوشه به دلیل سرعت بالا در مقیاس بالا برای پادها استفاده شده است. هر پاد در تنظیمات خود یک رابط به نام \lr{eth0} دارد که برای این ارتباط با این شبکه است. همچنین هر پاد یک آدرس آیپی از شبکه \lr{10.0.0.0/8} می‌گیرد.
	\section{\lr{Multus}}
	
	\lr{Multus} یک افزونه \lr{CNI} است که به عنوان یک رابط استاندارد برای اتصال پادها به شبکه عمل می‌کند. تفاوت اصلی آن با افزونه‌های ساده‌تر این است که به هر پاد اجازه می‌دهد بیش از یک رابط شبکه داشته باشد. به این ترتیب، یک پاد می‌تواند هم‌زمان به چندین شبکه متصل شود؛ مثلاً یک شبکه اصلی برای ارتباطات داخلی خوشه و یک یا چند شبکه دیگر برای دسترسی به سرویس‌های خاص یا منابع خارجی.
	
	این قابلیت به‌ویژه در سناریوهای پیشرفته، مانند شبکه‌های مخابراتی \lr{(NFV)} یا محیط‌های چندمستأجری\footnote{\lr{Multi-tenant}}، کاربرد زیادی دارد. \lr{Multus} همچنین می‌تواند با سایر افزونه‌های \lr{CNI} (مانند \lr{Calico} یا \lr{Flannel}) ترکیب شود و امکان مدیریت انعطاف‌پذیرتر و پیشرفته‌تر شبکه‌ها را در یک خوشه فراهم کند.
	
	همانطور که قبلا گفته شد، نیاز داریم تا یک شبکه عمومی برای ماشین های ویندوز در نظر بگیریم تا مجزا از شبکه های داخلی باشند و امکان دسترسی از خارج نیز وجود داشته باشد. پس بنابراین نیاز داشتیم تا به صورتی یک رابط دیگر نیز برای این شبکه ایجاد کنیم. برای اینکه بتوانیم دو رابط داشته باشیم ناچار هستیم از این \lr{CNI} استفاده کنیم.
\section{\lr{Linux bridge}}

	پل در لینوکس یا \lr{Linux Bridge} در واقع یک ابزار نرم‌افزاری در هسته‌ی لینوکس است که رفتار یک سوییچ لایه‌ی دوم\footnote{\lr{Switch} در لایه‌ی پیوند داده کار می‌کند و بر اساس آدرس‌های \lr{MAC} تصمیم به ارسال بسته‌ها می‌گیرد.} را شبیه‌سازی می‌کند. این پل می‌تواند چندین واسط شبکه (چه فیزیکی و چه مجازی) را به یکدیگر متصل کند و آن‌ها را در یک دامنه‌ی پخش\footnote{\lr{Broadcast Domain}: محدوده‌ای که پیام‌های پخش‌شده به همه‌ی دستگاه‌ها می‌رسد.} مشترک قرار دهد. در نتیجه، بسته‌های داده بر اساس آدرس مقصد \lr{MAC} بین واسط‌ها جابه‌جا می‌شوند، درست مانند اینکه همه‌ی آن‌ها به یک سوییچ واقعی متصل شده باشند. 
	
	ما برای اینکه ماشین های مجازی ویندوز را به شبکه عمومی متصل کنیم، نیاز داریم تا به طریقی  آنها را به آن شبکه از طریق رابط \lr{ens19} متصل کنیم. در حالت عادی ای این رابط فقط بسته هایی را ارسال و دریافت می‌کند که با آدرس \lr{MAC} آن همخوانی داشته باشند. بنابراین قادر به انتقال بسته های ماشین‌های ویندوز که \lr{MAC} متفاوتی دارند نیست. در نتیجه ما این رابط را به یک پل تبدیل می‌کنیم که ماشین‌های ویندوز نیز از طریق آن بتوانند بسته های خود را جا‌به‌جا کنند. 
	
	برای استفاده از این پل ها کافی است آنها را هم در \lr{netplan} تعریف کنیم. پس از اجرای آن تنظیمات، یک پل در لیست رابط ها ایجاد می‌شود. در سمت \lr{k8s} نیز باید یک رابط شبکه (\lr{NAD})\footnote{\lr{Netowrk Attachment definition}} به این پل ایجاد کنیم تا پاد‌ها بتوانند با آن ارتباط برقرار کنند. ما میتوانیم به \lr{ens19} آیپی بدهیم. اما ترجیح دادیم به آن هیچ آدرس آیپی اختصاص ندهیم تا کاملا همانند یک پل واقعی عمل کند.
	
	
\section{\lr{kubemacpool}}
یکی از مشکلاتی که بعدا ایجاد شد، این بود که پس از هر بار خاموش روشن کردن ماشین‌های ویندوز، یک آدرس \lr{MAC} رندوم به ماشین مجازی اختصاص داده میشد و \lr{DHCP} سرور مجبور بود که هربار یک آدرس \lr{IP} دیگر به ماشین ویندوز بدهد. در این حالت یک ماشین ویندوز پس از هربار خاموش روشن شدن یک آدرس \lr{IP} جدید داشت که مطلوب نبود. 

\lr{kubemacpool} یک افزونه است که دقیقا برای حل همین مشکل ایجاد شده است. ابتدا یک رنج آدرس \lr{MAC} برای آن تعریف می‌کنیم. سپس این افزونه خودش به هر ماشین یا پاد یک آدرس \lr{MAC} از آن رنج مشخص شده می‌دهد و این آدرس ثابت می‌ماند. بنابراین \lr{DHCP} سرور نیز آدرس \lr{IP} قبلی ماشین را به آن احتصاص می‌دهد. همچنین مدیریت اینکه آدرس های \lr{MAC} در شبکه یکتا بمانند نیز توسط همین افزونه انجام می‌شود.

	
	\chapter{بستر مجازی سازی در \lr{k8s}}
	\section{\lr{Kubevirt}}
	\section{منابع ماشین ها}
	\section{انتقال زنده}
	\section{تخصیص منابع به صورت زنده}
	\lipsum[8]
	
	\chapter{\lr{Windows image}}
	\section{گرفتن اطلاعات}
	\section{تنطیمات اضافی}
	\lipsum[9]
	
	\chapter{\lr{kubevirt-manager}}
	\chapter{نظارت}
	\section{\lr{Prometheus}}
	\section{\lr{Graphana}}
	\lipsum[10]
	
	% References
%	\begin{thebibliography}{99}
%		\bibitem{ref1} Author, \textit{Book or Paper Title}, Publisher, Year.
%		\bibitem{ref2} Another Author, ``Article Title'', \textit{Journal}, Year.
%	\end{thebibliography}
	
	% Appendix
	\appendix
	\chapter{اطلاعات اضافی}
	\lipsum[11]
	
\end{document}
